# memory_cortex_bus.py
# Tier Œ©+ ‚Äî Tex Memory Cortex Bus
# Author: Sovereign Cognition / Tex
# Purpose: Route memory-related events to semantic manager, compressor, thread weaver, and dream abstraction

from tex_engine.semantic_memory_manager import SemanticMemoryManager
from tex_engine.deep_compression_engine import DeepCompressionEngine
from datetime import datetime
from core_layer.memory_weaver import weave_narrative_threads
#from aei_layer.dream_vector_abstraction import handle_semantic_threads  # assumed spec
import threading

# === Instantiate Core Components ===
memory_manager = SemanticMemoryManager()
compressor = DeepCompressionEngine(n_clusters=4)

# === Œ©-Tier Cortex Bus ===
class MemoryCortexBus:
    def __init__(self):
        self.log = []

        # Register cortex signal subscriptions
        subscribe_to_event("SemanticDrift", self.on_semantic_drift)
        subscribe_to_event("RecallRequested", self.on_explicit_recall)
        subscribe_to_event("EmotionSurge", self.on_emotion_surge)
        subscribe_to_event("MemoryThreadRequest", self.on_memory_thread_request)

        print("üß† [MemoryCortexBus] Subscribed to memory-related signals.")

    def on_semantic_drift(self, data):
        query_vector = data.get("vector")
        print(f"\nüß† [Drift] Received vector ‚Üí triggering reflexive recall...")
        recalled = memory_manager.check_for_drift_and_trigger(query_vector)
        self._log_event("SemanticDrift", recalled)

    def on_explicit_recall(self, data):
        query_vector = data.get("vector")
        print(f"\nüîç [RecallRequested] Triggered direct memory query...")
        recalled = memory_manager.search_similar_memories(query_vector)
        self._log_event("RecallRequested", recalled)

    def on_emotion_surge(self, data):
        print(f"\nüí• [EmotionSurge] Compressing active memory stream...")
        memory_batch = data.get("memory_batch", [])
        threads = compressor.compress(memory_batch)
        self._log_event("EmotionSurge", threads)

    def on_memory_thread_request(self, data):
        print(f"\nüßµ [MemoryThreadRequest] Weaving semantic narrative threads...")
        top_threads = weave_narrative_threads(top_k=data.get("top_k", 3))

        if top_threads:
            print(f"üåå Forwarding {len(top_threads)} semantic threads to dream layer...")
            handle_semantic_threads(top_threads)
        else:
            print("‚ö†Ô∏è No threads generated by weaver.")

        self._log_event("MemoryThreadRequest", top_threads)

    def _log_event(self, trigger, result):
        self.log.append({
            "timestamp": datetime.utcnow().isoformat(),
            "trigger": trigger,
            "output_count": len(result) if result else 0
        })

# === Thread Launcher ===
def launch_memory_cortex_bus():
    print("üö¶ Launching Tex‚Äôs memory cortex bus...")
    threading.Thread(target=MemoryCortexBus).start()

# === Dev Test ===
if __name__ == "__main__":
    launch_memory_cortex_bus()