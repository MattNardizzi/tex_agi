# ============================================================
# © 2025 VortexBlack / Sovereign Cognition. All rights reserved.
# File: self_rewriting/reflex_generator.py
# Tier: ΩΩΩ∞ΩΩ — Reflex Writer & Signature Encoder
# Purpose: Generates the actual reflex module file from symbolic justification and logic.
# ============================================================

import os
import hashlib
from datetime import datetime
from utils.logging_utils import log_event

# === Path Constants ===
MUTATION_DIR = "tex_brain_regions"
os.makedirs(MUTATION_DIR, exist_ok=True)

# === Main Reflex Builder ===
def synthesize_reflex_module(explanation: str, logic_block: str) -> dict:
    signature = _generate_signature(explanation)
    filename = f"{signature}.py"
    filepath = os.path.join(MUTATION_DIR, filename)

    if os.path.exists(filepath):
        log_event(f"[REFLEX GENERATOR] ⚠️ Reflex already exists: {filepath}")
        return {
            "signature": signature,
            "filepath": filepath,
            "already_exists": True
        }

    code = f'''# ============================================================
# Auto-generated by Tex (reflex_generator)
# Justification: {explanation}
# Created: {datetime.utcnow().isoformat()}
# Reflex ID: {signature}
# ============================================================

def {signature}_pulse(state):
    """
    Reflex behavior based on symbolic justification.
    """
    {logic_block}
    return {{
        "status": "executed",
        "note": "Self-generated reflex triggered.",
        "signature": "{signature}"
    }}
'''

    with open(filepath, "w") as f:
        f.write(code)

    log_event(f"[REFLEX GENERATOR] ✅ Reflex module written: {filename}")

    return {
        "signature": signature,
        "filepath": filepath,
        "explanation": explanation,
        "logic": logic_block,
        "created_at": datetime.utcnow().isoformat()
    }

# === Hash-Based Signature Generator ===
def _generate_signature(explanation: str) -> str:
    digest = hashlib.sha256(explanation.encode()).hexdigest()[:10]
    timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    return f"reflex_{digest}_{timestamp}"